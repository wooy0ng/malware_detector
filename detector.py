import os
import re
import sys
import numpy as np
import pandas as pd
import pickle as pkl
from tqdm import tqdm
import pefile

from sklearn.feature_extraction import FeatureHasher
from sklearn.ensemble import RandomForestClassifier
from sklearn.linear_model import LogisticRegression
from sklearn.model_selection import train_test_split
from sklearn import metrics
import matplotlib.pyplot as plt

# return hashed features
def get_string_features(PATH, hasher, pbar):
    # regex
    regex = r'[ -~]{5,}'
    pattern = re.compile(regex)

    # get string
    with open(PATH, errors='ignore', encoding='ascii') as f:
        b2a_data = f.read()
    strings = pattern.findall(b2a_data)

    # hashing
    string_features = {}
    for string in strings:
        string_features[string] = 1
    
    hashed_features = hasher.transform([string_features])
    hashed_features = hashed_features.todense()
    hashed_features = np.array(hashed_features)
    hashed_features = hashed_features[0]
    
    if pbar: pbar.update(1)
    return hashed_features

def get_IAT_features(PATH, hasher, pbar):    
    features = {}
    try:
        pe = pefile.PE(PATH) 
        if hasattr(pe, 'DIRECTORY_ENTRY_IMPORT'):
            dll_name = pe.DIRECTORY_ENTRY_IMPORT[0]
            for func in dll_name.imports:
                if func.name: 
                    # print("{} in dll {}".format(func.name, dll_name.dll))
                    features[func.name] = 1
    # NE File
    except pefile.PEFormatError as err:
        # print("{} in file {}".format(err, PATH))
        pass
        
    hashed_features = hasher.transform([features])
    hashed_features = hashed_features.todense()
    hashed_features = np.array(hashed_features)
    hashed_features = hashed_features[0]
    
    if pbar: pbar.update(1)
    return hashed_features

def get_PE_header_features(PATH, df, pbar):
    try:
        pe = pefile.PE(PATH)
        features = {
            # DOS HEADER
            # 'e_magic' : pe.DOS_HEADER.e_magic,
            'e_lfanew' : pe.DOS_HEADER.e_lfanew,
            
            # FILE HEADER
            'Characteristics' : pe.FILE_HEADER.Characteristics,
            # 'Machine' : pe.FILE_HEADER.Machine,
            'NumberOfSections' : pe.FILE_HEADER.NumberOfSections,
            
            # Optional HEADER
            'ImageBase': pe.OPTIONAL_HEADER.ImageBase, 
            # 'Magic' : pe.OPTIONAL_HEADER.Magic,
            'Subsystem': pe.OPTIONAL_HEADER.Subsystem,
            'SizeOfImage' : pe.OPTIONAL_HEADER.SizeOfImage,
            
            # table's size
            'ImportTableSize': pe.OPTIONAL_HEADER.DATA_DIRECTORY[1].Size,
            'DebugTableSize': pe.OPTIONAL_HEADER.DATA_DIRECTORY[6].Size,
            'IATTableSize' : pe.OPTIONAL_HEADER.DATA_DIRECTORY[12].Size,
            
        }
    except pefile.PEFormatError as err:
        features = {
            # DOS HEADER
            # 'e_magic' : 0,
            'e_lfanew' : 0,
            
            # FILE HEADER
            'Characteristics' : 0,
            # 'Machine' : 0,
            'NumberOfSections' : 0,
            
            # Optional HEADER
            'ImageBase': 0,
            # 'Magic' : 0,
            'Subsystem': 0,
            'SizeOfImage' : 0,
            
            # table's size
            'ImportTableSize': 0,
            'DebugTableSize': 0,
            'IATTableSize' : 0,
        }
    except IndexError as err:
        pe = pefile.PE(PATH)
        features = {
            # DOS HEADER
            # 'e_magic' : pe.DOS_HEADER.e_magic,
            'e_lfanew' : pe.DOS_HEADER.e_lfanew,
            
            # FILE HEADER
            'Characteristics' : pe.FILE_HEADER.Characteristics,
            # 'Machine' : pe.FILE_HEADER.Machine,
            'NumberOfSections' : pe.FILE_HEADER.NumberOfSections,
            
            # Optional HEADER
            'ImageBase': pe.OPTIONAL_HEADER.ImageBase, 
            # 'Magic' : pe.OPTIONAL_HEADER.Magic,
            'Subsystem': pe.OPTIONAL_HEADER.Subsystem,
            'SizeOfImage' : pe.OPTIONAL_HEADER.SizeOfImage,
            
            # table's size
            'ImportTableSize': 0,
            'DebugTableSize': 0,
            'IATTableSize' : 0,
        }
        
    
    df = df.append(features, ignore_index=True)
    if pbar: pbar.update(1)
    
    return df

def PE_header_preprocessing(X):
    # preprocessing / one-hot encoding
    preprocessed_df = pd.DataFrame()
    
    df = pd.get_dummies(X['DebugTableSize'])
    columns_name = ['DebugTableSize_' + str(name) for name in df.columns]
    df.columns = columns_name
    preprocessed_df[columns_name] = df
    X.drop('DebugTableSize', axis='columns', inplace=True)
    
    df = pd.get_dummies(X['Subsystem'])
    columns_name = ['Subsystem_' + str(name) for name in df.columns]
    df.columns = columns_name
    preprocessed_df[columns_name] = df
    X.drop('Subsystem', axis='columns', inplace=True)
    
    X[preprocessed_df.columns] = preprocessed_df
    
    return X

def get_ROC_(Y_test, score, feature_info):
    try:
        fpr, tpr, thresholds = metrics.roc_curve(Y_test, score)
        plt.plot(fpr, tpr, 'r-')
        plt.xlabel("false positive rate")
        plt.ylabel("true positive rate")
        plt.title("ROC curve({})".format(feature_info))
        plt.savefig(feature_info + " ROC.png")
    except Exception as err:
        print("\t> cannot get ROC curve")
        sys.exit(1)
    print("\t> get " + feature_info + " ROC curve")
    plt.clf()
    return

def detector(malware_dir, benignware_dir, hasher):
    def get_files_name(PATH):
        paths = []
        for path in os.listdir(PATH):
            paths.append(os.path.join(PATH, path))
        return paths

    malware_files = get_files_name(malware_dir)
    benignware_files = get_files_name(benignware_dir)

    scores = []
    
    # 1) eigen string features 
    with tqdm(total=len(malware_files + benignware_files), desc="[+] get string features... ", ncols=100) as pbar:
        X = [get_string_features(PATH, hasher, pbar) for PATH in malware_files + benignware_files]
    pbar.close()

    Y = [1 for _ in range(len(malware_files))] + [0 for _ in range(len(benignware_files))]
    
    X_train, X_test, Y_train, Y_test = train_test_split(X, Y, test_size=0.2, random_state=5)
    model_string_features = RandomForestClassifier(64)
    model_string_features.fit(X_train, Y_train)
    
    score = model_string_features.score(X_test, Y_test)
    predict_probas = model_string_features.predict_proba(X_test)[:,-1]
    # get ROC curve
    get_ROC_(Y_test, predict_probas, "string")
    scores.append(score)
    print("\t> model score : %.2f" % score)
    


    # 2) eigen IAT features
    with tqdm(total=len(malware_files + benignware_files), desc="[+] get IAT function name features... ", ncols=100) as pbar:    
        X = [get_IAT_features(PATH, hasher, pbar) for PATH in malware_files + benignware_files]
    pbar.close()
    Y = [1 for _ in range(len(malware_files))] + [0 for _ in range(len(benignware_files))]    
    
    X_train, X_test, Y_train, Y_test = train_test_split(X, Y, test_size=0.2, random_state=5)
    
    model_IAT_features = RandomForestClassifier(64)
    model_IAT_features.fit(X_train, Y_train)
    
    score = model_IAT_features.score(X_test, Y_test)
    predict_probas = model_IAT_features.predict_proba(X_test)[:,-1]
    # get ROC curve
    get_ROC_(Y_test, predict_probas, "IAT table")
    scores.append(score)
    print("\t> model score : %.2f" % score)
    
    # 3) Individual features
    X = pd.DataFrame()
    with tqdm(total=len(malware_files + benignware_files), desc="[+] get Individual features... ", ncols=100) as pbar:
        for PATH in malware_files + benignware_files:
            X = get_PE_header_features(PATH, X, pbar) 
    pbar.close()
    X = PE_header_preprocessing(X)
    PE_header_columns = X.columns
    
    Y = pd.DataFrame(
        [1 for _ in range(len(malware_files))] + [0 for _ in range(len(benignware_files))], 
        columns=['result']).values.ravel()
    
    X_train, X_test, Y_train, Y_test = train_test_split(X, Y, test_size=0.2, random_state=5)
    
    model_Individual_features = LogisticRegression(solver='lbfgs')
    model_Individual_features.fit(X_train, Y_train)
    
    score = model_Individual_features.score(X_test, Y_test)
    predict_probas = model_Individual_features.predict_proba(X_test)[:,-1]
    # get ROC curve
    get_ROC_(Y_test, predict_probas, "PE header")
    scores.append(score)
    print("\t> model score : %.2f" % score)
    
    pkl.dump((model_string_features, model_IAT_features, model_Individual_features, hasher, PE_header_columns), open("saved_objects.pkl", "wb+"))
    
    
def scan_file(PATH):
    import sys
    if not os.path.exists("saved_objects.pkl"):
        print("error")
        sys.exit(1)
    with open("saved_objects.pkl", "rb+") as obj:
        model_string_features, model_IAT_features, model_Individual_features, hasher, PE_header_columns = pkl.load(obj)
    
    pbar = None
    string_features = get_string_features(PATH, hasher, pbar)
    IAT_features = get_IAT_features(PATH, hasher, pbar)
    
    tmp = pd.DataFrame([[0 for _ in range(len(PE_header_columns))]], columns=PE_header_columns)
    Individual_features = get_PE_header_features(PATH, tmp, pbar)
    Individual_features = PE_header_preprocessing(Individual_features).iloc[1,]
    Individual_features = Individual_features.fillna(0)
    
    string_proba = model_string_features.predict_proba([string_features])[:,1]
    IAT_proba = model_IAT_features.predict_proba([IAT_features])[:,1]
    header_proba = model_Individual_features.predict_proba([Individual_features])[:,1]
    
    if string_proba > 0.5:
        print("I think this file is malicious because of string_features / probability : {}".format(string_proba))
    else:
        print("I think this file is benign because of string_features / probability : {}".format(string_proba))
    
    if IAT_proba > 0.5:
        print("I think this file is malicious because of IAT function features / probability : {}".format(IAT_proba))
    else:
        print("I think this file is benign because of IAT function features / probability : {}".format(IAT_proba))
    
    if header_proba > 0.5:
        print("I think this file is malicious because of PE header features / probability : {}".format(header_proba))
    else:
        print("I think this file is benign because of PE header features / probability : {}".format(header_proba))
    




if __name__ == "__main__":
    malware_dir = '/home/project/Desktop/malware_detector/malware'
    benignware_dir = '/home/project/Desktop/malware_detector/benignware'

    if os.path.exists(malware_dir) and os.path.exists(benignware_dir):
        print("[+] TRAINING DIRECTORY EXISTS")
        
        hasher = FeatureHasher(20000)
        
        # detector(malware_dir, benignware_dir, hasher)
        if not os.path.exists('saved_objects.pkl'):
            detector(malware_dir, benignware_dir, hasher)
        scan_file('/home/project/Desktop/malware_detector/sample.exe')
